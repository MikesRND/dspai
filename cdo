#!/bin/bash
#
# cdo: Container "Do" command
# A script to run commands inside a Docker development container,
# handling special characters and interactive modes properly.
#
set -euo pipefail

# =============================================================================
# CONFIGURE THIS SCRIPT FOR YOUR PROJECT
#   Update DOCKER_COMPOSE_FILE to point to your docker-compose.yml file
#   Update DOCKER_SERVICE_NAME to the service name in your docker-compose.yml
# =============================================================================
DOCKER_COMPOSE_FILE=${DOCKER_COMPOSE_FILE:-docker-compose.yml}
DOCKER_SERVICE_NAME=${DOCKER_SERVICE_NAME:-dev}
# =============================================================================

show_usage() {
    cat <<EOF
Usage: $0 [OPTIONS] [COMMAND [ARGS...]]

Execute a command inside the Docker development container with proper handling of special characters.
Similar to 'sudo' but runs commands in the container environment instead of as root.

OPTIONS:
    -h, --help         Show this help message
    -u, --up           Start the container if not running (implies wait for start)
    -d, --down         Stop the container and exit
    -s, --shell        Enter interactive shell (ignore COMMAND)
    -i, --interactive  Force interactive mode (allocate a TTY)
    -n, --no-tty       Force non-interactive mode (no TTY)
    -U, --user USER    Override user (default: current user)
    -W, --workdir DIR  Override working directory
    -e, --env VAR=VALUE  Set environment variable

EXAMPLES:
    $0 -s              # Enter an interactive shell
    $0 -u -s           # Start container if needed, then enter shell
    $0 -d              # Stop the container
    $0 ls -la
    $0 echo "Hello World"
    $0 bash -c 'echo \$HOME'
    $0 grep "pattern with spaces" file.txt
    $0 python -c "print('Hello')"
    $0 find . -name "*.txt" -exec echo {} \\;

    # Override service name for different projects
    DOCKER_SERVICE_NAME=myservice $0 ls

EOF
}

DOCKER_COMPOSE=${DOCKER_COMPOSE:-docker compose -f "$DOCKER_COMPOSE_FILE"}

# Check if we're already inside a container
is_inside_container() {
    # Check for /.dockerenv file (common indicator)
    [[ -f /.dockerenv ]] && return 0

    # Check if running in a container via cgroup
    [[ -f /proc/1/cgroup ]] && grep -q docker /proc/1/cgroup && return 0

    return 1
}

is_container_running() {
    $DOCKER_COMPOSE ps -q "$DOCKER_SERVICE_NAME" 2>/dev/null | grep -q .
}

INTERACTIVE=""
TTY_EXPLICIT=false
USER_OVERRIDE=""
WORKDIR_OVERRIDE=""
ENV_VARS=()
SHELL_MODE=false
START_CONTAINER=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_usage
            exit 0
            ;;
        -u|--up)
            START_CONTAINER=true
            shift
            ;;
        -d|--down)
            echo "Stopping container '$DOCKER_SERVICE_NAME'..." >&2
            $DOCKER_COMPOSE down "$DOCKER_SERVICE_NAME"
            echo "Container stopped." >&2
            exit 0
            ;;
        -s|--shell)
            SHELL_MODE=true
            shift
            ;;
        -i|--interactive)
            INTERACTIVE="-it"
            TTY_EXPLICIT=true
            shift
            ;;
        -n|--no-tty)
            INTERACTIVE="-T"
            TTY_EXPLICIT=true
            shift
            ;;
        -U|--user)
            USER_OVERRIDE="$2"
            shift 2
            ;;
        -W|--workdir)
            WORKDIR_OVERRIDE="$2"
            shift 2
            ;;
        -e|--env)
            ENV_VARS+=("-e" "$2")
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            break
            ;;
    esac
done

if [[ $# -eq 0 && "$SHELL_MODE" == false && "$START_CONTAINER" == false ]]; then
    show_usage
    exit 0
fi

# If already inside the container, execute the command directly
if is_inside_container; then
    if [[ "$SHELL_MODE" == true ]]; then
        # Already in container, just start a shell
        exec bash
    elif [[ $# -gt 0 ]]; then
        # Execute the command directly
        exec "$@"
    else
        # No command provided and already inside
        exit 0
    fi
fi

if ! is_container_running; then
    if [[ "$START_CONTAINER" == true ]]; then
        echo "Starting container '$DOCKER_SERVICE_NAME'..." >&2
        USER_ID=$(id -u) GROUP_ID=$(id -g) USER=${USER:-developer} $DOCKER_COMPOSE up -d "$DOCKER_SERVICE_NAME"

        # Wait for container to be ready
        echo "Waiting for container to be ready..." >&2
        for i in {1..30}; do
            if is_container_running; then
                echo "Container is ready!" >&2
                break
            fi
            if [[ $i -eq 30 ]]; then
                echo "Error: Container failed to start within 30 seconds" >&2
                exit 1
            fi
            sleep 1
        done

        # If -u was used without a command, just exit after starting
        if [[ $# -eq 0 && "$SHELL_MODE" == false ]]; then
            exit 0
        fi
    else
        echo "Error: Container '$DOCKER_SERVICE_NAME' is not running" >&2
        echo "Start it with: $0 --up" >&2
        echo "Or use docker compose: USER_ID=\$(id -u) GROUP_ID=\$(id -g) $DOCKER_COMPOSE up -d" >&2
        exit 1
    fi
fi

if [[ "$TTY_EXPLICIT" != true ]]; then
    if [[ -t 0 && -t 1 ]]; then
        INTERACTIVE="-it"
    fi
fi

USER_SPEC=("--user" "$(id -u):$(id -g)")
if [[ -n "$USER_OVERRIDE" ]]; then
    USER_SPEC=("--user" "$USER_OVERRIDE")
fi

WORKDIR_SPEC=()
if [[ -n "$WORKDIR_OVERRIDE" ]]; then
    WORKDIR_SPEC=("--workdir" "$WORKDIR_OVERRIDE")
fi

if [[ "$SHELL_MODE" == true ]]; then
    exec $DOCKER_COMPOSE exec \
        $INTERACTIVE \
        "${USER_SPEC[@]}" \
        "${WORKDIR_SPEC[@]}" \
        "${ENV_VARS[@]}" \
        "$DOCKER_SERVICE_NAME" \
        bash
else
    ESCAPED_ARGS=()
    for arg in "$@"; do
        ESCAPED_ARGS+=("$(printf '%q' "$arg")")
    done

    COMMAND_STRING="${ESCAPED_ARGS[*]}"

    exec $DOCKER_COMPOSE exec \
        $INTERACTIVE \
        "${USER_SPEC[@]}" \
        "${WORKDIR_SPEC[@]}" \
        "${ENV_VARS[@]}" \
        "$DOCKER_SERVICE_NAME" \
        bash -c "$COMMAND_STRING"
fi